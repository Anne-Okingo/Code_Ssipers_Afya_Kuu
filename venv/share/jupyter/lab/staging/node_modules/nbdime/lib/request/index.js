// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
import { URLExt } from '@jupyterlab/coreutils/lib/url';
import { ServerConnection } from '@jupyterlab/services';
function urlRStrip(target) {
    if (target.slice(-1) === '/') {
        return target.slice(0, -1);
    }
    return target;
}
export function handleError(response) {
    if (!response.ok) {
        if (response.status === 500 && response.body) {
            return response.text().then(body => {
                throw new Error(body);
            });
        }
        throw new Error(`${response.status} ${response.statusText}`);
    }
    return Promise.resolve(response);
}
/**
 * Make a request to an nbdime API.
 */
export function requestApiPromise(baseUrl, apiPath, argument) {
    const url = URLExt.join(urlRStrip(baseUrl), apiPath);
    let request = {
        method: 'POST',
        body: JSON.stringify(argument),
    };
    let settings = ServerConnection.makeSettings();
    return ServerConnection.makeRequest(url, request, settings).then(handleError);
}
/**
 * Make a request to an nbdime API.
 */
export function requestApi(baseUrl, apiPath, argument, onComplete, onFail) {
    requestApiPromise(baseUrl, apiPath, argument).then(onComplete, (error) => {
        onFail(error.message);
    });
}
/**
 * Make a POST request passing a JSON argument and receiving a JSON result.
 */
export function requestApiJsonPromise(baseUrl, apiPath, argument) {
    return requestApiPromise(baseUrl, apiPath, argument).then(response => {
        return response.json();
    });
}
/**
 * Make a POST request passing a JSON argument and receiving a JSON result.
 */
export function requestApiJson(baseUrl, apiPath, argument, callback, onError) {
    requestApiJsonPromise(baseUrl, apiPath, argument).then(callback, (error) => {
        onError(error.message);
    });
}
/**
 * Make a diff request for the given base/remote specifiers (filenames)
 */
export function requestDiffPromise(base, remote, baseUrl) {
    return requestApiJsonPromise(baseUrl, 'api/diff', { base, remote });
}
/**
 * Make a diff request for the given base/remote specifiers (filenames)
 */
export function requestDiff(base, remote, baseUrl, onComplete, onFail) {
    requestApiJson(baseUrl, 'api/diff', { base, remote }, onComplete, onFail);
}
/**
 * Make a diff request for the given base/remote specifiers (filenames)
 */
export function requestMergePromise(base, local, remote, baseUrl) {
    return requestApiJsonPromise(baseUrl, 'api/merge', { base, local, remote });
}
/**
 * Make a diff request for the given base/remote specifiers (filenames)
 */
export function requestMerge(base, local, remote, baseUrl, onComplete, onFail) {
    requestApiJson(baseUrl, 'api/merge', { base, local, remote }, onComplete, onFail);
}
//# sourceMappingURL=index.js.map