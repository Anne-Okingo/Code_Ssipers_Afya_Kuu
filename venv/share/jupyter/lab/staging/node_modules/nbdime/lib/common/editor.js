// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
import { StreamLanguage } from '@codemirror/language';
import { YFile } from '@jupyter/ydoc';
import { CodeEditorWrapper, CodeEditor } from '@jupyterlab/codeeditor';
import { CodeMirrorEditorFactory, EditorExtensionRegistry, EditorLanguageRegistry, EditorThemeRegistry, parseMathIPython, ybinding, } from '@jupyterlab/codemirror';
import { nullTranslator } from '@jupyterlab/translation';
export class EditorWidget extends CodeEditorWrapper {
    /**
     * Store all editor instances for operations that
     * need to loop over all instances.
     */
    constructor(options) {
        const { factory, value, ...others } = options;
        const sharedModel = new YFile();
        if (value) {
            sharedModel.source = value;
        }
        const model = new CodeEditor.Model({ sharedModel });
        super({
            model: model,
            factory: factory ?? createEditorFactory(),
            editorOptions: others,
        });
        this.staticLoaded = false;
    }
    get cm() {
        return this.editor.editor;
    }
    get doc() {
        return this.editor.doc;
    }
}
function createExtensionsRegistry(themes) {
    const extensions = new EditorExtensionRegistry();
    // Register default extensions
    const extensionNameList = [
        'lineNumbers',
        'readOnly',
        'theme',
        'allowMultipleSelections',
        'tabSize',
    ];
    for (const extensionFactory of EditorExtensionRegistry.getDefaultExtensions({
        themes,
    })) {
        for (const extensionName of extensionNameList) {
            if (extensionFactory.name === extensionName) {
                extensions.addExtension(extensionFactory);
            }
        }
    }
    extensions.addExtension({
        name: 'shared-model-binding',
        factory: options => {
            const sharedModel = options.model.sharedModel;
            return EditorExtensionRegistry.createImmutableExtension(ybinding({
                ytext: sharedModel.ysource,
                undoManager: sharedModel.undoManager ?? undefined,
            }));
        },
    });
    return extensions;
}
function createLanguagesRegistry() {
    const languages = new EditorLanguageRegistry();
    // Register default languages
    for (const language of EditorLanguageRegistry.getDefaultLanguages()) {
        languages.addLanguage(language);
    }
    // Add Jupyter Markdown flavor here to support
    // code block highlighting.
    languages.addLanguage({
        name: 'ipythongfm',
        mime: 'text/x-ipythongfm',
        load: async () => {
            const [m, tex] = await Promise.all([
                import('@codemirror/lang-markdown'),
                import('@codemirror/legacy-modes/mode/stex'),
            ]);
            return m.markdown({
                base: m.markdownLanguage,
                codeLanguages: (info) => languages.findBest(info),
                extensions: [
                    parseMathIPython(StreamLanguage.define(tex.stexMath).parser),
                ],
            });
        },
    });
    return languages;
}
function createThemeRegistry() {
    const themes = new EditorThemeRegistry();
    for (const theme of EditorThemeRegistry.getDefaultThemes()) {
        themes.addTheme(theme);
    }
    return themes;
}
export function createEditorFactory(options = {}) {
    const factory = new CodeMirrorEditorFactory({
        extensions: options.extensions ?? createExtensionsRegistry(createThemeRegistry()),
        languages: options.languages ?? createLanguagesRegistry(),
        translator: options.translator ?? nullTranslator,
    });
    return factory.newInlineEditor.bind(factory);
}
//# sourceMappingURL=editor.js.map